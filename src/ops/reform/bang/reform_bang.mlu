#include <bang.h>
#include <bang_device_functions.h>
#include "reform_bang.h"
#include "../../../devices/bang/common_bang.h"

template <typename T>
__mlu_device__ void reformKernel(T *source, T *destination, int *strideSrc, int *strideDest, int *shape, int n, int dimsize, int nDim){
    
    if (dimsize * sizeof(T) > GDRAM_MAX_SIZE){
        int maxNum = GDRAM_MAX_SIZE / sizeof(T);
        int remain = dimsize % maxNum;
        int repeat = (dimsize - remain) / maxNum;

        int remainT = n % taskDim;
        int stepEasy = (n - remainT) / taskDim;
        int stepHard = stepEasy + 1;
        int step = (taskId < remainT ? stepHard : stepEasy);
        int indStart = (taskId < remainT ? taskId * stepHard : (taskId - remainT) * stepEasy + remainT * stepHard);
        
        for(int i = indStart; i < indStart + step; i++){
            int inds = 0;
            int indd = 0;
            int indi = i;
            for (int j = nDim - 2; j >= 0; --j) {
                inds += (indi % shape[j]) * strideSrc[j];
                indd += (indi % shape[j]) * strideDest[j];
                indi /= shape[j];
            }
            for (int s = 0; s < repeat; s++){
                __memcpy(destination + indd + s * maxNum, source + inds + s * maxNum, maxNum * sizeof(T), GDRAM2GDRAM); 
            }
            if (remain){
                __memcpy(destination + indd + repeat * maxNum, source + inds + repeat * maxNum, remain * sizeof(T), GDRAM2GDRAM); 
            }                              
        }      
    }
    else {
        int remainT = n % taskDim;
        int stepEasy = (n - remainT) / taskDim;
        int stepHard = stepEasy + 1;
        int step = (taskId < remainT ? stepHard : stepEasy);
        int indStart = (taskId < remainT ? taskId * stepHard : (taskId - remainT) * stepEasy + remainT * stepHard);
        
        for(int i = indStart; i < indStart + step; i++){
            int inds = 0;
            int indd = 0;
            int indi = i;
            for (int j = nDim - 2; j >= 0; --j) {
                inds += (indi % shape[j]) * strideSrc[j];
                indd += (indi % shape[j]) * strideDest[j];
                indi /= shape[j];
            }
            __memcpy(destination + indd, source + inds, dimsize * sizeof(T), GDRAM2GDRAM);                                  
        }      
    }
    
}

template <typename T>
__mlu_global__ void reformUnion1(T *source, T *destination, int *strideSrc, int *strideDest, int *shape, int n, int dimsize, int ndim){
    
    reformKernel<T>(source, destination, strideSrc, strideDest, shape, n, dimsize, ndim);
    
}

void reform(cnrtQueue_t queue, void *y, void *x, int *y_stride, int *x_stride, int *shape, int n, int dimsize, int ndim){
    
    auto y_ = reinterpret_cast<half *>(y);
    auto x_ = reinterpret_cast<half *>(x);

    cnrtDim3_t dim = {16, 1, 1};
    cnrtFunctionType_t ktype = CNRT_FUNC_TYPE_UNION1;
    
    reformUnion1<half><<<dim, ktype, queue>>>(x_, y_, x_stride, y_stride, shape, n, dimsize, ndim);
    cnrtQueueSync(queue);
    
}

void reform_bang(Tensor y, Tensor x, void *stream) {
    ASSERT_EQ(y.layout->ndim, x.layout->ndim);
    int ndim = y.layout->ndim;
    ASSERT(ndim >= 2);
    for (int i = 0; i < ndim; ++i) {
        ASSERT_EQ(y.layout->shape[i], x.layout->shape[i]);
    }
    ASSERT_EQ(y.layout->strides[ndim - 1], y.layout->dt.size);
    ASSERT_EQ(x.layout->strides[ndim - 1], x.layout->dt.size);

    int x_stride[ndim], y_stride[ndim], shape[ndim];
    int n = 1;
    for (int i = 0; i < ndim; i++) {
        x_stride[i] = static_cast<int>(x.layout->strides[i])/y.layout->dt.size;
        y_stride[i] = static_cast<int>(y.layout->strides[i])/y.layout->dt.size;
        shape[i] = static_cast<int>(y.layout->shape[i]);
        n *= shape[i];
    }
    int dimsize = shape[ndim - 1];
    n /= dimsize;
    int *mlu_strideX, *mlu_strideY, *mlu_shape;
    CNRT_CHECK(cnrtMalloc((void **)&mlu_strideX, ndim * sizeof(int)));
    CNRT_CHECK(cnrtMalloc((void **)&mlu_strideY, ndim * sizeof(int)));
    CNRT_CHECK(cnrtMalloc((void **)&mlu_shape, ndim * sizeof(int)));
    CNRT_CHECK(cnrtMemcpy(mlu_strideX, x_stride, ndim * sizeof(int), cnrtMemcpyHostToDev));
    CNRT_CHECK(cnrtMemcpy(mlu_strideY, y_stride, ndim * sizeof(int), cnrtMemcpyHostToDev));
    CNRT_CHECK(cnrtMemcpy(mlu_shape, shape, ndim * sizeof(int), cnrtMemcpyHostToDev));
    auto queue = reinterpret_cast<cnrtQueue_t>(stream);
    
    reform(queue, y.data, x.data, mlu_strideY, mlu_strideX, mlu_shape, n, dimsize, ndim);
    cnrtFree(mlu_strideX);
    cnrtFree(mlu_strideY);
    cnrtFree(mlu_shape);
    
}
