#include "bang.h"
#include "bang_device_functions.h"
#include "cnrt.h"
#include "rearrange_bang.h"
#include "../../../devices/bang/common_bang.h"
#include <stdlib.h>

const int SRC_MAX_SIZE = 1024 * 1024 * 128; 
template<typename T>
__mlu_global__ void rearrange(
    T *dst,
    T const *src,
    uint64_t *mlu_shape_dst,
    uint64_t *mlu_shape_src,
    int64_t *mlu_strides_dst,
    int64_t *mlu_strides_src,
    int r,
    int ndim){
    const int maxNum = SRC_MAX_SIZE/sizeof(T);

    int remainT = r % taskDim;
    int stepEasy = (r - remainT) / taskDim;
    int stepHard = stepEasy + 1;
    int step = (taskId < remainT ? stepHard : stepEasy);
    int indStart = (taskId < remainT ? taskId * stepHard : remainT * stepHard + (taskId - remainT) * stepEasy);
    
    int dimsize = mlu_shape_dst[ndim - 1];
    if(dimsize < maxNum){
        for(int i = indStart; i < indStart + step; i++){
            int tidS = 0;
            int tidD = 0;
            int indi = i;
            for(int j = ndim - 2; j >= 0; --j){
                tidS += (indi % mlu_shape_src[j]) * mlu_strides_src[j];
                tidD += (indi % mlu_shape_dst[j]) * mlu_strides_dst[j];
                indi /= mlu_shape_src[j];
            }
            __memcpy(dst + tidD, src + tidS, dimsize * sizeof(T), GDRAM2GDRAM);
        }
       
    }
    else{
        int remain = dimsize % maxNum;
        int repeat = (dimsize - remain) / maxNum;
        for(int i = indStart; i < indStart + step; i++){
            int tidS = 0;
            int tidD = 0;
            int indi = i;
            for(int j = ndim - 2; j >= 0; --j){
                tidS += (indi % mlu_shape_src[j]) * mlu_strides_src[j];
                tidD += (indi % mlu_shape_dst[j]) * mlu_strides_dst[j];
                indi /= mlu_shape_src[j];
            }
            for(int index = 0; index < repeat; index++){
                __memcpy(dst + tidD + index * maxNum, src + tidS + index * maxNum, maxNum * sizeof(T), GDRAM2GDRAM);
            }
            if(remain){
                __memcpy(dst + tidD + repeat * maxNum, src + tidS + repeat * maxNum, remain * sizeof(T), GDRAM2GDRAM);
            }
        }
        
    }   
}
template<typename T>
void rearrangeUnion(cnrtQueue_t queue, void *destination, void const *source, uint64_t *mlu_shape_dst,
    uint64_t *mlu_shape_src,
    int64_t *mlu_strides_dst,
    int64_t *mlu_strides_src,
    int r,
    int ndim) {
    auto dst = reinterpret_cast< T *>(destination);
    auto src = reinterpret_cast<const T *>(source);
    cnrtDim3_t k_dim;
    cnrtFunctionType_t k_type;

    k_dim.x = 4;
    k_dim.y = 1;
    k_dim.z = 1;
    k_type = CNRT_FUNC_TYPE_UNION1;

    rearrange<T><<<k_dim, k_type, queue>>>(dst, src, mlu_shape_dst, mlu_shape_src, mlu_strides_dst, mlu_strides_src, r, ndim);
    
    cnrtQueueSync(queue);
}
void rearrange_bang_f16(RearrangeBangDescriptor_t desc, void *dst,
                               void *src,
                               void *stream) {
    auto queue = reinterpret_cast<cnrtQueue_t>(stream);
    int r = desc->r;
    int ndim = desc->ndim;

    rearrangeUnion<half>(queue, dst, src, desc->mlu_shape_dst, desc->mlu_shape_src, desc->mlu_strides_dst, desc->mlu_strides_src, r, ndim);
}
infiniopStatus_t bangRearrange(RearrangeBangDescriptor_t desc,
                               void *dst,
                               void *src,
                               void *stream) {
                              
    if (cnrtSetDevice(desc->device_id) != cnrtSuccess) {
        return STATUS_BAD_DEVICE;
    }
    
    if (dtype_eq(desc->dtype, F16)) {
        rearrange_bang_f16(desc, dst, src, stream);
        
        return STATUS_SUCCESS;
    }
    return STATUS_BAD_TENSOR_DTYPE;
}
