#include "bang.h"
#include "bang_device_functions.h"
#include "cnrt.h"
#include "rotary_embedding_bang.h"
#include "../../../devices/bang/common_bang.h"
#include "../../utils.h"

const int SRC_MAX_SIZE = 1024 * 16;//16 = 256/16
__nram__  char nram_buffer[NRAM_MAX_SIZE];

template <typename T>
__mlu_global__ void RoPE(T *destination, uint64_t const *pos_ids, float const *sin_table, float const *cos_table, int stride_0, int stride_1, int nt, int nh, int dimsize) {//axis=-1

    const int maxNum = SRC_MAX_SIZE/sizeof(float);
    
    int othersize = nt * nh;

    int segsize = sizeof(T);
    int srcStrideL = 2 * sizeof(T);
    int destStrideL = 1 * sizeof(T);
    
    int srcStrideW = 1 * sizeof(T);
    int destStrideW = 2 * sizeof(T);

    int remainT = othersize % taskDim;
    int stepEasy = (othersize - remainT) / taskDim;
    int stepHard = stepEasy + 1;
    int step = (taskId < remainT ? stepHard : stepEasy);
    int indStart = (taskId < remainT ? taskId * stepHard : (taskId - remainT) * stepEasy + remainT * stepHard);

    if(nt < maxNum){
        char *nram_buffer1 = nram_buffer + nt * sizeof(uint64_t);
        uint64_t *srcP = (uint64_t *)nram_buffer;//[nt]

        __memcpy(srcP, pos_ids, nt * sizeof(uint64_t), GDRAM2NRAM);
        
        if(dimsize >= maxNum){
            char *nram_buffer2 = nram_buffer1 + 10 * maxNum * sizeof(float);
            float *srcSin = (float *)nram_buffer1;//[2 * maxNum]
            float *srcCos = srcSin + 2 * maxNum;//[2 * maxNum]
            float *sin0 = srcSin + 2 * maxNum;//[maxNum]
            float *cos0 = sin0 + maxNum;//[maxNum]
            float *sin1 = cos0 + maxNum;//[maxNum]
            float *cos1 = sin1 + maxNum;//[maxNum]
            float *tmpa = cos1 + maxNum;//[maxNum]
            float *tmpb = tmpa + maxNum;//[maxNum]
            

            T *src = (T *)nram_buffer2;//[2 * maxNum]
            T *srca = src + 2 * maxNum;//[maxNum]
            T *srcb = srca + maxNum;//[maxNum]


            int segnum = 2 * maxNum;
            
            int remain = dimsize % (2 * maxNum);
            int repeat = (dimsize - remain) /  (2 * maxNum);
            for(int i = indStart; i < indStart + step; i++){
                int indd = 0;
                int indi = i;
                indd += (indi % nh) * stride_1;
                indi /= nh;
                indd += (indi % nt) * stride_0;
                int index = srcP[(indi % nt)] * dimsize;
                for(int s = 0; s < repeat; s++){
                    __memcpy(srcSin, sin_table + index + s * 2 * maxNum, 2 * maxNum * sizeof(float), GDRAM2NRAM);
                    __memcpy(sin1, srcSin + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum);     
                    __memcpy(sin0, srcSin, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum); 

                    __memcpy(srcCos, cos_table + index + s * 2 * maxNum, 2 * maxNum * sizeof(float), GDRAM2NRAM);
                    __memcpy(cos1, srcCos + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum);     
                    __memcpy(cos0, srcCos, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum); 

                    __memcpy(src, destination + indd + s * 2 * maxNum, 2 * maxNum * sizeof(T), GDRAM2NRAM);
                    __memcpy(srcb, src + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum);     
                    __memcpy(srca, src, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum); 
                    __bang_half2float(tmpa, srca, maxNum);
                    __bang_half2float(tmpb, srcb, maxNum);

                    __bang_mul(cos0, tmpa, cos0, maxNum);
                    __bang_mul(sin0, tmpb, sin0, maxNum);
                    __bang_mul_scalar(sin0, sin0, -1.0, maxNum);
                    __bang_add(cos0, cos0, sin0, maxNum);//结果临时存储在cos0上

                    __bang_mul(sin1, tmpa, sin1, maxNum);
                    __bang_mul(cos1, tmpb, cos1, maxNum);
                    __bang_add(cos1, sin1, cos1, maxNum);

                    __bang_float2half_dn(srca, cos0, maxNum);
                    __bang_float2half_dn(srcb, cos1, maxNum);

                    __memcpy(src, srca, segsize, NRAM2NRAM, destStrideW, srcStrideW, segnum);
                    __memcpy(src + 1, srcb, segsize, NRAM2NRAM, destStrideW, srcStrideW, segnum);
                    __memcpy(destination + indd + s * 2 * maxNum, src, 2 * maxNum * sizeof(T), NRAM2GDRAM);

                    
                }
                if(remain){
                    __memcpy(srcSin, sin_table + index + repeat * 2 * maxNum, remain * sizeof(float), GDRAM2NRAM);
                    __memcpy(sin1, srcSin + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum);     
                    __memcpy(sin0, srcSin, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum); 

                    __memcpy(srcCos, cos_table + index + repeat * 2 * maxNum, remain * sizeof(float), GDRAM2NRAM);
                    __memcpy(cos1, srcCos + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum);     
                    __memcpy(cos0, srcCos, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum); 

                    __memcpy(src, destination + indd + repeat * 2 * maxNum, remain * sizeof(T), GDRAM2NRAM);
                    __memcpy(srcb, src + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, remain);     
                    __memcpy(srca, src, segsize, NRAM2NRAM, destStrideL, srcStrideL, remain); 
                    __bang_half2float(tmpa, srca, maxNum);
                    __bang_half2float(tmpb, srcb, maxNum);

                    __bang_mul(cos0, tmpa, cos0, maxNum);
                    __bang_mul(sin0, tmpb, sin0, maxNum);
                    __bang_mul_scalar(sin0, sin0, -1.0, maxNum);
                    __bang_add(cos0, cos0, sin0, maxNum);//结果临时存储在cos0上

                    __bang_mul(sin1, tmpa, sin1, maxNum);
                    __bang_mul(cos1, tmpb, cos1, maxNum);
                    __bang_add(cos1, sin1, cos1, maxNum);

                    __bang_float2half_dn(srca, cos0, maxNum);
                    __bang_float2half_dn(srcb, cos1, maxNum);

                    __memcpy(src, srca, segsize, NRAM2NRAM, destStrideW, srcStrideW, remain);
                    __memcpy(src + 1, srcb, segsize, NRAM2NRAM, destStrideW, srcStrideW, remain);
                    __memcpy(destination + indd + repeat * 2 * maxNum, src, remain * sizeof(T), NRAM2GDRAM);

                    
                }
            }
            
        }
        else{
            
            int segnum = dimsize;
            int dh = dimsize / 2;

            char *nram_buffer2 = nram_buffer1 + (2 * dimsize + 6 * dh) * sizeof(float);
            float *srcSin = (float *)nram_buffer1;//[dimsize]
            float *srcCos = srcSin + dimsize;//[dimsize]
            float *sin0 = srcSin + dimsize;//[dh]
            float *cos0 = sin0 + dh;//[dh]
            float *sin1 = cos0 + dh;//[dh]
            float *cos1 = sin1 + dh;//[dh]
            float *tmpa = cos1 + dh;//[dh]
            float *tmpb = tmpa + dh;//[dh]
            

            T *src = (T *)nram_buffer2;//[dimsize]
            T *srca = src + dimsize;//[dh]
            T *srcb = srca + dh;//[dh]

            for(int i = indStart; i < indStart + step; i++){
                int indd = 0;
                int indi = i;
                indd += (indi % nh) * stride_1;
                indi /= nh;
                indd += (indi % nt) * stride_0;

                int index = srcP[(indi % nt)] * dimsize;
                
                __memcpy(srcSin, sin_table + index, dimsize * sizeof(float), GDRAM2NRAM);
                __memcpy(sin1, srcSin + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum);     
                __memcpy(sin0, srcSin, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum); 

                __memcpy(srcCos, cos_table + index, dimsize * sizeof(float), GDRAM2NRAM);
                __memcpy(cos1, srcCos + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum);     
                __memcpy(cos0, srcCos, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum); 
                
                __memcpy(src, destination + indd, dimsize * sizeof(T), GDRAM2NRAM);
                __memcpy(srca, src, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum); 
                __memcpy(srcb, src + 1, segsize, NRAM2NRAM, destStrideL, srcStrideL, segnum);     
                __bang_half2float(tmpa, srca, dh);
                __bang_half2float(tmpb, srcb, dh);

                __bang_mul(cos0, tmpa, cos0, dh);
                __bang_mul(sin0, tmpb, sin0, dh);
                __bang_mul_scalar(sin0, sin0, -1.0, dh);
                __bang_add(cos0, cos0, sin0, dh);//结果临时存储在cos0上

                __bang_mul(sin1, tmpa, sin1, dh);
                __bang_mul(cos1, tmpb, cos1, dh);
                __bang_add(cos1, sin1, cos1, dh);

                __bang_float2half_dn(srca, cos0, dh);
                __bang_float2half_dn(srcb, cos1, dh);
                
                __memcpy(src, srca, segsize, NRAM2NRAM, destStrideW, srcStrideW, segnum);
                __memcpy(src + 1, srcb, segsize, NRAM2NRAM, destStrideW, srcStrideW, segnum);
                __memcpy(destination + indd, src, dimsize * sizeof(T), NRAM2GDRAM);
            }
            

        }
    }
    
}
template<typename T>
void RoPEUnion(cnrtQueue_t queue, void *destination, void const *pos_ids, void const *sin_table, void const *cos_table, int stride_0, int stride_1, int nt, int nh, int dimsize) {
    
    auto pos_ = reinterpret_cast<uint64_t const *>(pos_ids);
    auto sin_ = reinterpret_cast<float const *>(sin_table);
    auto cos_ = reinterpret_cast<float const *>(cos_table);
    auto t_ = reinterpret_cast<T *>(destination);

    cnrtDim3_t k_dim;
    cnrtFunctionType_t k_type;

    k_dim.x = 4;
    k_dim.y = 1;
    k_dim.z = 1;
    k_type = CNRT_FUNC_TYPE_UNION1;

    RoPE<T><<<k_dim, k_type, queue>>>(t_, pos_, sin_, cos_, stride_0, stride_1, nt, nh, dimsize);
    cnrtQueueSync(queue);
    
}

void RoPE_bang_f16(RoPEBangDescriptor_t desc, void *t,
                         void const *pos_ids,
                         void const *sin_table,
                         void const *cos_table, void *stream) {
    auto queue = reinterpret_cast<cnrtQueue_t>(stream);
    auto nt = desc->seq_len,
         nh = desc->nhead,
         dimsize = desc->dim;
    auto stride_0 = desc->strides[0];
    auto stride_1 = desc->strides[1];
    
    RoPEUnion<half>(queue, t, pos_ids, sin_table, cos_table, stride_0, stride_1, nt, nh, dimsize);
    
}

infiniopStatus_t bangRoPE(RoPEBangDescriptor_t desc,
                          void *workspace,
                          uint64_t workspace_size,
                          void *t,
                          void const *pos_ids,
                          void const *sin_table,
                          void const *cos_table,
                          void *stream) {
    if (t == nullptr || pos_ids == nullptr || sin_table == nullptr || cos_table == nullptr)
        return STATUS_BAD_PARAM;

    if (dtype_eq(desc->dtype, F16)) {
        RoPE_bang_f16(desc, t,
                                  pos_ids,
                                  sin_table,
                                  cos_table, stream);
    } else {
        return STATUS_BAD_TENSOR_DTYPE;
    }

    return STATUS_SUCCESS;
}
